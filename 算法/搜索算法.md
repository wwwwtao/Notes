## 二分查找

```js   binary_search.js
/* 二分查找（双闭区间） */
function binarySearch(nums, target) {
    // 初始化双闭区间 [0, n-1] ，即 i, j 分别指向数组首元素、尾元素
    let i = 0,
        j = nums.length - 1;
    // 循环，当搜索区间为空时跳出（当 i > j 时为空）
    while (i <= j) {
        // 计算中点索引 m ，使用 parseInt() 向下取整
        const m = parseInt(i + (j - i) / 2);
        if (nums[m] < target)
            // 此情况说明 target 在区间 [m+1, j] 中
            i = m + 1;
        else if (nums[m] > target)
            // 此情况说明 target 在区间 [i, m-1] 中
            j = m - 1;
        else return m; // 找到目标元素，返回其索引
    }
    // 未找到目标元素，返回 -1
    return -1;
}

/* 二分查找（左闭右开） */
function binarySearchLCRO(nums, target) {
    // 初始化左闭右开 [0, n) ，即 i, j 分别指向数组首元素、尾元素+1
    let i = 0,
        j = nums.length;
    // 循环，当搜索区间为空时跳出（当 i = j 时为空）
    while (i < j) {
        // 计算中点索引 m ，使用 parseInt() 向下取整
        const m = parseInt(i + (j - i) / 2);
        if (nums[m] < target)
            // 此情况说明 target 在区间 [m+1, j) 中
            i = m + 1;
        else if (nums[m] > target)
            // 此情况说明 target 在区间 [i, m) 中
            j = m;
        // 找到目标元素，返回其索引
        else return m;
    }
    // 未找到目标元素，返回 -1
    return -1;
}
```

**上面二分查找是基于递推（迭代）实现的。现在我们基于分治（递归）来实现它。**
```java   binary_search_recur.java

/* 二分查找：问题 f(i, j) */
int dfs(int[] nums, int target, int i, int j) {
    // 若区间为空，代表无目标元素，则返回 -1
    if (i > j) {
        return -1;
    }
    // 计算中点索引 m
    int m = (i + j) / 2;
    if (nums[m] < target) {
        // 递归子问题 f(m+1, j)
        return dfs(nums, target, m + 1, j);
    } else if (nums[m] > target) {
        // 递归子问题 f(i, m-1)
        return dfs(nums, target, i, m - 1);
    } else {
        // 找到目标元素，返回其索引
        return m;
    }
}

/* 二分查找 */
int binarySearch(int[] nums, int target) {
    int n = nums.length;
    // 求解问题 f(0, n-1)
    return dfs(nums, target, 0, n - 1);
}
```

## 10.4. 重识搜索算法

「搜索算法 Searching Algorithm」用于在数据结构（例如数组、链表、树或图）中搜索一个或一组满足特定条件的元素。
 根据实现思路，搜索算法总体可分为两种：
 1. 通过遍历数据结构来定位目标元素，例如数组、链表、树和图的遍历等。
 2. 利用数据组织结构或数据包含的先验信息，实现高效元素查找，例如二分查找、哈希查找和二叉搜索树查找等。

### 10.4.1. 暴力搜索

暴力搜索通过遍历数据结构的每个元素来定位目标元素。
 - 「线性搜索」适用于数组和链表等线性数据结构。它从数据结构的一端开始，逐个访问元素，直到找到目标元素或到达另一端仍没有找到目标元素为止。
- 「广度优先搜索」和「深度优先搜索」是图和树的两种遍历策略。广度优先搜索从初始节点开始逐层搜索，由近及远地访问各个节点。深度优先搜索是从初始节点开始，沿着一条路径走到头为止，再回溯并尝试其他路径，直到遍历完整个数据结构。

### 10.4.2. 自适应搜索

自适应搜索利用数据的特有属性（例如有序性）来优化搜索过程，从而更高效地定位目标元素。
 - 「二分查找」利用数据的有序性实现高效查找，仅适用于数组。
- 「哈希查找」利用哈希表将搜索数据和目标数据建立为键值对映射，从而实现查询操作。
- 「树查找」在特定的树结构（例如二叉搜索树）中，基于比较节点值来快速排除节点，从而定位目标元素。

### 10.4.3. 搜索方法选取

给定大小为 \(n\) 的一组数据，我们可以使用线性搜索、二分查找、树查找、哈希查找等多种方法在该数据中搜索目标元素。
 | 搜索方法 | 查找元素 | 插入元素 | 删除元素 | 额外空间 | 数据预处理 | 数据是否有序 |
|----------|----------|----------|----------|----------|------------|--------------|
| 线性搜索 | \(O(n)\) | \(O(1)\) | \(O(n)\) | \(O(1)\) | /          | 无序         |
| 二分查找 | \(O(\log n)\) | \(O(n)\) | \(O(n)\) | \(O(1)\) | 排序 \(O(n \log n)\) | 有序 |
| 树查找   | \(O(\log n)\) | \(O(\log n)\) | \(O(\log n)\) | \(O(n)\) | 建树 \(O(n \log n)\) | 有序 |
| 哈希查找 | \(O(1)\) | \(O(1)\) | \(O(1)\) | \(O(n)\) | 建哈希表 \(O(n)\) | 无序 |

#### 线性搜索

- 通用性较好，无需任何数据预处理操作。假如我们仅需查询一次数据，那么其他三种方法的数据预处理的时间比线性搜索的时间还要更长。
- 适用于体量较小的数据，此情况下时间复杂度对效率影响较小。
- 适用于数据更新频率较高的场景，因为该方法不需要对数据进行任何额外维护。

#### 二分查找

- 适用于大数据量的情况，效率表现稳定，最差时间复杂度为 \(O(\log n)\) 。
- 数据量不能过大，因为存储数组需要连续的内存空间。
- 不适用于高频增删数据的场景，因为维护有序数组的开销较大。

#### 哈希查找

- 适合对查询性能要求很高的场景，平均时间复杂度为 \(O(1)\) 。
- 不适合需要有序数据或范围查找的场景，因为哈希表无法维护数据的有序性。
- 对哈希函数和哈希冲突处理策略的依赖性较高，具有较大的性能劣化风险。
- 不适合数据量过大的情况，因为哈希表需要额外空间来最大程度地减少冲突，从而提供良好的查询性能。

#### 树查找

- 适用于海量数据，因为树节点在内存中是离散存储的。
- 适合需要维护有序数据或范围查找的场景。
- 在持续增删节点的过程中，二叉搜索树可能产生倾斜，时间复杂度劣化至 \(O(n)\) 。
- 若使用 AVL 树或红黑树，则各项操作可在 \(O(\log n)\) 效率下稳定运行，但维护树平衡的操作会增加额外开销。
