第 2 章 HTML 性能优化

<!-- 1. 内联和外部文件引入 -->

    <style>
        /*
        内联
            优点：
                减少 HTTP 请求
            缺点：
                1. 没办法复用
                2. 使得 HTML 文件变大，加载时间变长
                3. 代码都写到 HTML 文件中，不利于后期的维护？
                    工程化的手段可以解决这个问题 （可以写在外面 帮我们内联进来）
                        源码到可以上线的代码
        */
    </style>

    <!--
        通过外部文件引入
            优点：
                1. 很好的复用代码
                    有效利用浏览器的静态资源缓存
                2. 代码分离，利于后期维护
            缺点：
                增加了 HTTP 请求
    -->
    建议：内联首屏必备的 CSS 和 JS
    CSS 放在页面前面  JS 放在后面 !!
    和 DOM 无关的 JS 或者 和屏幕适配要尽早加载的 JS 也可以放在前面

            <!-- 2. 避免重复的资源请求
        文件压缩
        合并 CSS JS 文件 （但是也要注意大小）      通过工具
        缓存（后端的活）

            <!-- 2.2 图片和其他优化
<!--
        大、多
            HTTP 请求大
                图片压缩处理
                使用更高压缩比格式的图片
                    webp
                尽量少用图片
                    使用图标字体代替图片图标 !!
                    CSS 画图
            HTTP 请求多
                合理使用 base64 内嵌图片 !!
                合并静态资源图片 !!
                    雪碧图  !!
    -->

    <!-- 减少 DOM 元素的嵌套层级 -->

    <!-- 避免空连接 href、src -->

    <!-- 尽量避免使用 table/iframe 等慢元素 -->   // 浏览器渲染慢 要把所有 table 读完再渲染出来

    <!-- 主要内容和次要内容的位置 -->

            <!-- 3.1 CSS 选择器优化

        /*不要使用类选择器和 ID 选择器修饰元素标签，这样多此一举，还会降低效率。*/
        /*保持简单，不要使用嵌套过多过于复杂的选择器*/  推荐 3 个
        /*浏览器从右向左解析 CSS*/
            /*嵌套少*/
            /*权重低 便于使用的时候覆盖*/

        /*避免通配选择器*/ css result 的时候要给那些元素设置默认样式 就写那些就 OK 了

        /*避免类正则的属性选择器*/  高级的属性选择器 建议少用

        /*提取公用部分*/ 合并用简写属性

        /*避免使用 CSS @import 引用加载 CSS*/

        /*使用 CSS3 动画，代替 DOM 动画*/   !

        /*优先考虑 flex 不滥用 float*/    !

            <!-- 4.1 DOM 操作优化

<!--
        总结
            DOM 操作很奢侈，很耗性能

                加快单次 DOM 操作
                ( 尽量使用 id 选择器  合理使用选择器层级）

                减少 DOM 操作的次数
                合理缓存 DOM 对象 / 操作  cloneNode(true);   // 复制节点  带 true  复制内容

                缓存 DOM.length
                每次。length 都要计算，用一个变量保存这个值

                使用 DocumentFragment 优化多次的 appendChild

                使用一次 innerHTML

                不要直接修改 style，通过添加 class 修改
                （在最终渲染的时候 浏览器会重排 然后重绘  重排：计算元素位置  重绘：计算样式）
    -->

            <!-- 4.2 事件优化

        // 使用事件代理，避免直接事件绑定

        // 事件节流       如下高频事件可以使用定时器
        // scroll resize mousemove touchmove

        资源的按需加载 看源码  （懒加载）
        1. 通过额外的类名 把需要预加载的资源获取到数组
        2. 滚动条的时候添加事件 比如把资源加载出来
        3. 判断数组中的元素是否滚动到了可视区域     ( getBoundingClientRect() 方法返回元素在视口中的位置）
        4. 到了就把资源加载出来 比如把 src 换成真的 src  然后记得把加载完成的资源在数组中删除 splice()  然后如果是循环 索引还要减去一

        预加载
