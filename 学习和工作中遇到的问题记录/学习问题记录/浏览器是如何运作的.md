#### 浏览器是个多进程结构，

1. 浏览器进程：控制除标签页外的用户界面，包括地址，书签，后退，前进按钮等，以及负责与浏览器其他进程负责协调工作 2.
2. 缓存进程
3. 网络进程  发起网络请求
4. 渲染器进程    渲染 Tab  有可能会为每个标签页是一个渲染进程
5. GPU 进程  渲染
6. 插件进程    内置插件

#### 渲染进程的过程

1. 浏览器通过网络请求后获取 html 数据，通过 tcp 传给渲染器进程
2. DOM - 主线程将 html 解析构造 DOM 树
3. style - 样式计算
4. layoutTree - dom+style 根据 dom 树和样式生成 layoutTree
5. paint - 绘制  通过遍历 Layout Tree 生成绘制顺序表
6. laryer - 布局  然后根据主进程将 layoutTree 和绘制信息表传给合成器线程
7. 合成器线程  - 将得到的信息分图层分成更小的图块
8. 栅格线程    -    将更小的图块进行栅格化 raster，返还给合成器线程 draw quads 图块信息  存储在 GPU 中
9. frame 合成器将栅格线程返回的图块合成帧交给浏览器进程
10. 浏览器进程  收到一帧的图像后传给 GPU 进行渲染

#### 重排：

当改变 dom 的属性时，会重新进行样式计算，会重新布局和绘制

#### 重绘：

当改变颜色时，只会发生样式计算和绘制 (layer)

#### requestAnimationFrame()

会将主线程的任务分散到每一帧的间隔，从而不影响动画的流程

#### Fiber

react 利用浏览器的空闲时间做优化

#### Transform

会直接运行合成器线程，所以不会感染主线程的渲染
在移动端使用 3d 转换可以优化性能（如果设备有 3d 加速引擎 GPU 可以提高性能 , 2d 转换是无法调用 GPU，2G 是靠的 CPU）

#### CSS 的本质

CSS 的本质就是绘制语法糖，把一堆预设的绘制指令结合成一句话，背后则是描述性的绘制命令包括绘制位置，
如何绘制。如果把所有盒子模型在同一平面，会导致每一轮 EventLoop 需要计算的内容可能因为过多无法保证帧率，同时更重要的是无法保证封装绘制指令后用户的“灵活性”，所以绘制肯定是需要设计分层（也叫：文档流分层）的，这就是 position。

结合浏览器，首先它完成 HTML 相应的 lexer 和 parser 后，负责整合我们页面中的 <link>、<style>、以及内联样式，产出的结果是 styleSheets，也是页面所有的样式。
之后浏览器需要做的是把 styleSheet  中的 “描述语法糖”，转换成标准属性（如 height: 10vm，background: white; 转换成 px 与 十六进制颜色表示法），而大部分标准转换的属性的计算需要 V8 配合，另一部分用 automaton 可以解决。
根据它的描述，紧接着进行 CSS（层叠样式表） 经典的继承、层叠，生成最后的格式化样式，也就是 getComputedStyle。由于它和 V8 配合了。调用他之后的属性均会进行回流，同时也说明渲染期间也经历了非常轮的 EventLoop，这也可以理解。
浏览器会生成布局树，这代替了 Render Tree。主要是确定绘制位置，以及过滤 <head> 以及不可见的 Node。
与 PhotoShop 一致，根据文档流的层次，生成图层树。每个图层仅描述自身的内容。最后根据图层信息生成绘制列表，这是一堆指令与样式的组合，也是交给后续负责渲染的合成线程的 task list。
以上过程都是在渲染进程做的，之后会进入合成线程进行 print。GPU 加速也是意味着此属性拥有直接进行合成线程处理的过程，跳过回流和重绘，实现硬件加速，不仅如此更有 CSS 可以直接生成一个仅使用 GPU 加速的图层！
