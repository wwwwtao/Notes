### 硬核字节面试 https://blog.51cto.com/u_15473285/4855769

#### 一面

- 1. 浏览器缓存有哪几种类型？
  ![浏览器九大缓存方法](./%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%9D%E5%A4%A7%E7%BC%93%E5%AD%98%E6%96%B9%E6%B3%95.md)

- 2. chrome 80+ 对 cache 的改动点了解吗？

  谷歌在 2020 年 2 月 4 号发布的 Chrome80 版本（schedule）会逐渐屏蔽第三方 Cookie，即**默认为所有 Cookie 加上 SameSite=Lax** 属性（Cookies default to SameSite=Lax），并且拒绝为不安全的 Cookie 设置 SameSite=None 属性（Reject insecure SameSite=None cookies），这样是为了从源头屏蔽跨站请求伪造 CSRF（Cross Site Request Forgery）漏洞。

  **SameSite 属性**
  Chrome 51 开始，浏览器的 Cookie 新增加了一个 SameSite 属性，用来防止 CSRF 攻击 和用户追踪（第三方恶意获取 cookie），限制第三方 Cookie，从而减少安全风险。
  SameSite 属性可以设置三个值：**Strict、Lax、None**。

  **Strict**：严格，完全禁止第三方获取 cookie，跨站点时，任何情况下都不会发送 cookie；只有当前网页的 URL 与请求目标一致，才会带上 Cookie。这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态。

  **Lax**：防范跨站，大多数情况下禁止获取 cookie，除非导航到目标网址的 GET 请求（链接、预加载、GET 表单）；设置了 Strict 或 Lax 以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 SameSite 属性。

  ```js
  // Set-Cookie: CookieName=CookieValue; SameSite=Strict;

  // SameSite 属性的默认 SameSite=Lax 【该操作适用于 2019 年 2 月 4 号谷歌发布 Chrome 80 稳定版之后的版本】
  // Set-Cookie: CookieName=CookieValue; SameSite=Lax;

  // 必须同时设置 Secure 属性（Cookie 只能通过 HTTPS 协议发送），否则无效。 【该操作适用于 2019 年 2 月 4 号谷歌发布 Chrome 80 稳定版之后的版本】
  // Set-Cookie: widget_session=abc123; SameSite=None; Secure
  ```

  请求类型	   示例	                             正常情况	               Lax
  链接	   `<a href="..."></a>`	                 发送 Cookie	      发送 Cookie
  预加载	  `<link rel="prerender" href="..."/>` 发送 Cookie	      发送 Cookie
  GET 表单	`<form method="GET" action="...">`	 发送 Cookie	      发送 Cookie
  POST 表单	`<form method="POST" action="...">`	 发送 Cookie	      不发送
  iframe	  `<iframe src="..."></iframe>`	      发送 Cookie	        不发送
  AJAX	    `$.get("...")`	                    发送 Cookie	        不发送
  Image	     `<img src="...">`	                发送 Cookie	        不发送
  None：没有限制。

- 3. cache 如何做到在不同域的情况下，还可以共享 cookie，且不考虑 samesite 和 domain 设置

- 4. 如果本地资源里面有一个 10 mb+ 的图片，它又是整个网页的背景图片，你如何优化它，让它不影响网页的渲染速度？
  1. 对于图片懒加载，可以为页面添加一个滚动条事件，判断图片是否在可视区域内或者即将进入可视区域，优先加载。
  2. 如果为幻灯片、相册文件等，可以使用图片预加载技术，对于当前展示图片的前一张图片和后一张图片优先下载。
  3. 如果图片为 CSS 图片，可以使用 CSS Sprite、SVG sprite、 Icon font、Base64 等技术。
  4. 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩得特别小的缩略图，以提高用户体验。
  5. 如果图片展示区域小于图片的真实大小，则应在服务器端根据业务需要先行进行图片压缩，图片压缩后，图片大小与展示的就一致了。

- 5. react 17 和 18 分别做了什么优化

- 6. react 17 的合成事件的具体改进点在什么地方

- 7. react 什么情况下 state 是同步的什么情况下是异步的

- 8. react 的 state 异步的情况下是个宏任务吗？

- 9. 看见你使用了 MVC 的形式开发组件，依赖注入的原理说下

- 10. 如果我想让某个类的属性继承其他的类，那么这步的依赖注入应该如何做？

- 11. **V8 中的隐藏类（Hidden Classes）和内联缓存（Inline Caching）https://zhuanlan.zhihu.com/p/469962133**

- 12. 知道隐藏类的作用后，我们在编码的时候应该做哪些操作可以提高编码执行效率，至少说两点
  1. 保证以相同的顺序实例化对象属性，这样可以保证它们共享相同的隐藏类。
  2. 在对象实例化后向对象添加属性将会迫使隐藏类改变，这将会使也已经进行行内缓存的方法的访问速度变慢。所以，请尽量保证，在构造器内进行所有的属性声明。
  3. 不停执行相同方法的代码会比总在执行不同方法的代码速度快。

- 13. babel 我看你也挺了解的，请说明如何优化直接 import polyfill 整个包的情况。

- 14. babel runtime 和 helper 有何区别？

- 15. 它们和 preset-env 有何关系？

- 16. 为什么最新的 babel 草案（Array.prototype.at），没在 preset-env 的支持范围

- 17. preset-env 的 stage 和上一个问题的关系

- 18. babel 的原理

- 19. babel-plugin-import 主要做了什么操作

- 20. import 插件对于当前的 bundle 环境，你认为还有什么价值？

#### 二面

- Http 2.x 和 Http 1.x 有啥区别？

- Http 2.x 有哪些特性？

- Hpack 做了什么？

- PSK 有啥缺点？

- 为什么选择 qiankun，什么场景需要使用微应用？

- qiankun 和其他方案相比到底做了什么，有什么优势？

- qiankun 和 single-spa 的区别？
