当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。

https://www.jianshu.com/p/778d7b926f53  // 什么是执行上下文？什么是调用栈？  ！！！
全局执行上下文（局部执行上下文），全局存储器（声明的函数啊 变量啊存储的地方）和调用栈（也就是后进先出的栈 也就是为什么 JS 是异步单线程的原因）

VO 按照如下顺序填充： ！！！
1. 函数参数（若未传入，初始化该参数值为 undefined)
2. 函数声明（若发生命名冲突，会覆盖别人）
3. 变量声明（初始化变量值为 undefined，若发生命名冲突，会被忽略）

最后还有一个值得注意的问题：在 ES6 中不存在函数提升，算是修复了 ES5 得一个 bug   只有函数表达式才有函数提升

eval(string)    //string	必需。要计算的字符串，其中含有要计算的 JavaScript 表达式或要执行的语句。
返回值
通过计算 string 得到的值（如果有的话）。

### 阮一峰学习 Javascript 闭包（Closure） https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html

### 前端面试官问闭包，怎样回答脱颖而出 https://blog.csdn.net/weixin_45822171/article/details/122317790

1. 闭包是什么？
  闭包是 js 的一种语法特性。
  闭包就是能够读取其他函数内部变量的函数
  创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。——《JavaScript 高级程序设计》

2. 为什么要使用闭包？
  原因：Javascript 语言的特殊之处，就在于函数内部可以直接读取全局变量。
  但是在函数外部自然无法读取函数内的局部变量。出于种种原因，我们有时候需要得到函数内的局部变量。那就是在函数的内部，再定义一个函数。

3. 你能写一个闭包出来吗？

```js
  function outerFn(){
      var data = 10
      var innerFn = function(){
            data += 1
            console.log(data)
      }
  return innerFn
  }
  var result = outerFn()
  result() //11
  result() //12
// 现有一个名为 outerFn 的函数，它的内部包含一个已经声明的变量 data 和一个内部函数 innerFn。一般情况下，是无法访问或修改 data 的，但是 innerFn 可以访问到 data，我们通过调用 return 出的 innerFn，就可以间接的去修改和访问到 data 的数据了。
// 这样的做法，被总结称为 闭包。

// 那么如何能访问或修改到一个函数内部的变量呢？
// 函数的 return 就是这个传送门，可以将一个内部函数送出外部函数。 即使无法直接访问到外部函数内部的变量，也可以通过 return 出的内部函数去访问或修改外部函数的变量。
```

4. 闭包的用途？
闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。

5. 闭包解决了什么问题？
  （在什么场景下用到它呢，就是问它解决的什么问题）
  1. 不必为函数命名，避免污染全局变量；
  2. 提供对局部变量的间接访问，按需求进行共享和长期保存；
  3. 维持变量，使其不被垃圾回收。
  4. 内部形成单独的块级作用域，通过闭包实现变量 / 方法的私有化

6. 闭包的优缺点？
  优点：简单好用；
  缺点：闭包使用不当可能造成内存泄露；
  因为闭包中引用到的包裹函数中定义的变量永远不会被释放，所以我们应该在必要的时候，及时释放这个闭包函数。

7. 内存泄露是什么？怎么解决闭包产生的内存泄露？
  内存泄露是指你用不到（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。
  - 闭包产生的内存泄露怎么办？
  1. 在退出函数之前，将不使用的局部变量赋值为 null;
  2. 避免变量的循环赋值和引用。
  3. 利用 Jquery 释放自身指定的所有事件处理程序。
  由于 jQuery 考虑到了内存泄漏的潜在危害，所以它会手动释放自己指定的所有事件处理程序。 只要坚持使用 jQuery 的事件绑定方法，就可以一定程度上避免这种特定的常见原因导致的内存泄漏。

8. 使用闭包的注意点
  1. 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

  2. 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

9. 垃圾回收是什么？
  垃圾回收是一种自动的内存管理机制。当一个电脑上的动态内存不再需要时，就应该予以释放，以让出内存，这种内存资源管理，称为垃圾回收。

  垃圾回收的方法有：标记清除、引用计数。
  标记清除法：从根集合触发，标记处需要回收的对象，清除被标记的对象。
  引用计数法：就是记录每个对象被引用的次数，每次新建对象、赋值引用和删除引用的同时更新计数器，如果计数器值为 0 则直接回收内存。很明显，引用计数最大的优势是暂停时间短。

10. 思考题
  阮一峰老师写的教程《阮一峰学习 Javascript 闭包（Closure）》
  http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html

代码片段一：

```js
var name = "The Window";
　　var object = {
　　　　name : "My Object",
　　　　getNameFunc : function(){
　　　　　　return function(){
　　　　　　　　return this.name;
　　　　　　};
　　　　}
　　};
console.log(object.getNameFunc()());
//The Window
// 注释：getNameFunc 前面没有使用 var 关键字，它是一个全局变量，而不是局部变量。所以它读的是全局变量 the window，返回的 this.name 是 the window。
```

代码片段二：

```js
var name = "The Window";
　　var object = {
　　　　name : "My Object",
　　　　getNameFunc : function(){
　　　　　　var that = this;
　　　　　　return function(){
　　　　　　　　return that.name;
　　　　　　};
　　　　}
　　};
console.log(object.getNameFunc()());
//My Object
```
